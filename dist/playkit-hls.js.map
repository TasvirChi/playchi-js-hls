{"version":3,"sources":["./hls/webpack/universalModuleDefinition","./hls/playkit-hls.js","./hls/webpack/bootstrap 2a6bb622a298a5cddf82","./hls/external {\"commonjs\":\"playkit-js\",\"commonjs2\":\"playkit-js\",\"amd\":\"playkit-js\",\"root\":\"Playkit\"}","./hls/external {\"commonjs\":\"hls.js\",\"commonjs2\":\"hls.js\",\"amd\":\"hls.js\",\"root\":\"Hls\"}","./hls/./index.js","./hls/./hls-adapter.js","./hls/./default-config.json","./hls/./errors.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","NAME","VERSION","undefined","_playkitJs","_hlsAdapter","_hlsAdapter2","obj","default","isSupported","registerMediaSourceAdapter","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","_get","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","_hls","_hls2","_defaultConfig","_errors","HlsAdapter","_BaseMediaSourceAdapt","videoElement","source","config","_logger","debug","version","_this","_config","Utils","mergeDeep","DefaultConfig","_addBindings","hlsConfig","hasPropertyPath","playback","options","html5","hls","mimeType","canHlsPlayType","_hlsMimeTypes","includes","toLowerCase","toString","warn","isHlsSupported","_this2","on","Events","ERROR","e","data","_onError","MANIFEST_LOADED","_onManifestLoaded","bind","LEVEL_SWITCHED","_onLevelSwitched","AUDIO_TRACK_SWITCHED","_onAudioTrackSwitched","startTime","_this3","_loadPromise","Promise","resolve","onLevelUpdated","off","LEVEL_UPDATED","tracks","_playerTracks","startPosition","_sourceObj","url","loadSource","attachMedia","_videoElement","_trigger","BaseMediaSourceAdapter","CustomEvents","ABR_MODE_CHANGED","mode","isAdaptiveBitrateEnabled","_this4","then","_removeBindings","detachMedia","destroy","audioTracks","_parseAudioTracks","videoTracks","_parseVideoTracks","levels","textTracks","_parseTextTracks","subtitleTracks","concat","hlsAudioTracks","settings","id","active","audioTrack","label","language","lang","index","push","AudioTrack","hlsVideoTracks","startLevel","bandwidth","bitrate","width","height","VideoTrack","hlsTextTracks","kind","type","TextTrack","videoTrack","currentLevel","textTrack","_disableAllTextTracks","_onTrackChanged","nextLevel","autoLevelEnabled","liveEdge","liveSyncDuration","duration","liveSyncDurationCount","details","targetduration","NaN","currentTime","_getLiveEdge","live","event","startLoad","_parseTracks","find","track","level","vidTextTracks","errorType","errorDetails","fatal","error","ErrorTypes","NETWORK_ERROR","Error","Severity","CRITICAL","Category","NETWORK","Code","HTTP_ERROR","MEDIA_ERROR","_handleMediaError","RECOVERABLE","MEDIA","HLS_FATAL_MEDIA_ERROR","PLAYER","Html5Events","severity","_ref","HlsJsErrorMap","category","code","now","performance","recover","_checkTimeDeltaHasPassed","_recoverDecodingErrorDate","recoverDecodingErrorDelay","_recoverDecodingError","_recoverSwapAudioCodecDate","recoverSwapAudioCodecDelay","_recoverSwapAudioCodec","delay","recoverMediaError","swapAudioCodec","isLive","getLogger","fragLoadingMaxRetry","_defineProperty","_HlsJsErrorMap","ErrorDetails","MANIFEST_LOAD_ERROR","MANIFEST","MANIFEST_LOAD_TIMEOUT","TIMEOUT","MANIFEST_PARSING_ERROR","HLSJS_CANNOT_PARSE","LEVEL_LOAD_ERROR","LEVEL_LOAD_TIMEOUT","LEVEL_SWITCH_ERROR","BITRATE_SWITCH_ISSUE","FRAG_LOAD_ERROR","FRAG_LOOP_LOADING_ERROR","FRAG_LOAD_TIMEOUT","FRAG_PARSING_ERROR","HLS_FRAG_PARSING_ERROR","BUFFER_APPEND_ERROR","HLS_BUFFER_APPEND_ISSUE","BUFFER_APPENDING_ERROR","HLS_BUFFER_APPENDING_ISSUE","BUFFER_STALLED_ERROR","HLS_BUFFER_STALLED_ERROR"],"mappings":"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","file":"playkit-hls.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"playkit-js\"), require(\"hls.js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"playkit-js\", \"hls.js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PlaykitJsHls\"] = factory(require(\"playkit-js\"), require(\"hls.js\"));\n\telse\n\t\troot[\"PlaykitJsHls\"] = factory(root[\"Playkit\"], root[\"Hls\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"playkit-js\"), require(\"hls.js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"playkit-js\", \"hls.js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PlaykitJsHls\"] = factory(require(\"playkit-js\"), require(\"hls.js\"));\n\telse\n\t\troot[\"PlaykitJsHls\"] = factory(root[\"Playkit\"], root[\"Hls\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NAME = exports.VERSION = undefined;\n\nvar _playkitJs = __webpack_require__(0);\n\nvar _hlsAdapter = __webpack_require__(3);\n\nvar _hlsAdapter2 = _interopRequireDefault(_hlsAdapter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _hlsAdapter2.default;\nexports.VERSION = \"1.5.0\";\nexports.NAME = \"playkit-js-hls\";\n\n// Register hls adapter to the media source adapter provider.\n\nif (_hlsAdapter2.default.isSupported()) {\n  (0, _playkitJs.registerMediaSourceAdapter)(_hlsAdapter2.default);\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _hls = __webpack_require__(1);\n\nvar _hls2 = _interopRequireDefault(_hls);\n\nvar _defaultConfig = __webpack_require__(4);\n\nvar _errors = __webpack_require__(5);\n\nvar _playkitJs = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Adapter of hls.js lib for hls content.\n * @classdesc\n */\nvar HlsAdapter = function (_BaseMediaSourceAdapt) {\n  _inherits(HlsAdapter, _BaseMediaSourceAdapt);\n\n  _createClass(HlsAdapter, null, [{\n    key: 'createAdapter',\n\n\n    /**\n     * Factory method to create media source adapter.\n     * @function createAdapter\n     * @param {HTMLVideoElement} videoElement - The video element that the media source adapter work with.\n     * @param {Object} source - The source Object.\n     * @param {Object} config - The player configuration.\n     * @returns {IMediaSourceAdapter} - New instance of the run time media source adapter.\n     * @static\n     */\n\n    /**\n     * The hls player instance.\n     * @member {any} _hls\n     * @private\n     */\n\n\n    /**\n     * last recover date from decoding error\n     * @type {number}\n     * @private\n     */\n\n\n    /**\n     * last recover date from audio swap codec operation\n     * @type {number}\n     * @private\n     */\n\n\n    /**\n     * The load promise\n     * @member {Promise<Object>} - _loadPromise\n     * @type {Promise<Object>}\n     * @private\n     */\n\n    /**\n     * Reference to the player tracks.\n     * @member {Array<Track>} - _playerTracks\n     * @type {Array<Track>}\n     * @private\n     */\n\n    /**\n     * The adapter logger.\n     * @member {any} _logger\n     * @static\n     * @private\n     */\n    value: function createAdapter(videoElement, source, config) {\n      var hlsConfig = {};\n      if (_playkitJs.Utils.Object.hasPropertyPath(config, 'playback.options.html5.hls')) {\n        hlsConfig = config.playback.options.html5.hls;\n      }\n      return new this(videoElement, source, hlsConfig);\n    }\n\n    /**\n     * Checks if hls adapter can play a given mime type.\n     * @function canPlayType\n     * @param {string} mimeType - The mime type to check.\n     * @returns {boolean} - Whether the hls adapter can play a specific mime type.\n     * @static\n     */\n\n    /**\n     * The supported mime types by the hls adapter.\n     * @member {Array<string>} _hlsMimeType\n     * @static\n     * @private\n     */\n\n    /**\n     * The id of the adapter.\n     * @member {string} id\n     * @static\n     * @private\n     */\n\n  }, {\n    key: 'canPlayType',\n    value: function canPlayType(mimeType) {\n      var canHlsPlayType = typeof mimeType === 'string' ? HlsAdapter._hlsMimeTypes.includes(mimeType.toLowerCase()) : false;\n      HlsAdapter._logger.debug('canPlayType result for mimeType:' + mimeType + ' is ' + canHlsPlayType.toString());\n      return canHlsPlayType;\n    }\n\n    /**\n     * Checks if hls adapter can play a given drm data.\n     * For hls.js it always returns false.\n     * @returns {boolean} - Whether the hls adapter can play a specific drm data.\n     * @static\n     */\n\n  }, {\n    key: 'canPlayDrm',\n    value: function canPlayDrm() {\n      HlsAdapter._logger.warn('canPlayDrm result is false');\n      return false;\n    }\n\n    /**\n     * Checks if the hls adapter is supported.\n     * @function isSupported\n     * @returns {boolean} - Whether hls is supported.\n     * @static\n     */\n\n  }, {\n    key: 'isSupported',\n    value: function isSupported() {\n      var isHlsSupported = _hls2.default.isSupported();\n      HlsAdapter._logger.debug('isSupported:' + isHlsSupported);\n      return isHlsSupported;\n    }\n\n    /**\n     * @constructor\n     * @param {HTMLVideoElement} videoElement - The video element which will bind to the hls adapter\n     * @param {Object} source - The source object\n     * @param {Object} config - The media source adapter configuration\n     */\n\n  }]);\n\n  function HlsAdapter(videoElement, source, config) {\n    _classCallCheck(this, HlsAdapter);\n\n    HlsAdapter._logger.debug('Creating adapter. Hls version: ' + _hls2.default.version);\n\n    var _this = _possibleConstructorReturn(this, (HlsAdapter.__proto__ || Object.getPrototypeOf(HlsAdapter)).call(this, videoElement, source, config));\n\n    _this._config = _playkitJs.Utils.Object.mergeDeep({}, _this._config, _defaultConfig.DefaultConfig);\n    _this._hls = new _hls2.default(_this._config);\n    _this._addBindings();\n    return _this;\n  }\n\n  /**\n   * Adds the required bindings with hls.js.\n   * @function _addBindings\n   * @private\n   * @returns {void}\n   */\n\n\n  _createClass(HlsAdapter, [{\n    key: '_addBindings',\n    value: function _addBindings() {\n      var _this2 = this;\n\n      this._hls.on(_hls2.default.Events.ERROR, function (e, data) {\n        _this2._onError(data);\n      });\n      this._hls.on(_hls2.default.Events.MANIFEST_LOADED, this._onManifestLoaded.bind(this));\n      this._hls.on(_hls2.default.Events.LEVEL_SWITCHED, this._onLevelSwitched.bind(this));\n      this._hls.on(_hls2.default.Events.AUDIO_TRACK_SWITCHED, this._onAudioTrackSwitched.bind(this));\n    }\n\n    /**\n     * Load the video source\n     * @function load\n     * @param {number} startTime - Optional time to start the video from.\n     * @returns {Promise<Object>} - The loaded data\n     * @override\n     */\n\n  }, {\n    key: 'load',\n    value: function load(startTime) {\n      var _this3 = this;\n\n      if (!this._loadPromise) {\n        this._loadPromise = new Promise(function (resolve) {\n          var onLevelUpdated = function onLevelUpdated() {\n            _this3._hls.off(_hls2.default.Events.LEVEL_UPDATED, onLevelUpdated);\n            resolve({ tracks: _this3._playerTracks });\n          };\n          _this3._hls.on(_hls2.default.Events.LEVEL_UPDATED, onLevelUpdated);\n          if (startTime) {\n            _this3._hls.startPosition = startTime;\n          }\n          if (_this3._sourceObj && _this3._sourceObj.url) {\n            _this3._hls.loadSource(_this3._sourceObj.url);\n            _this3._hls.attachMedia(_this3._videoElement);\n            _this3._trigger(_playkitJs.BaseMediaSourceAdapter.CustomEvents.ABR_MODE_CHANGED, { mode: _this3.isAdaptiveBitrateEnabled() ? 'auto' : 'manual' });\n          }\n        });\n      }\n      return this._loadPromise;\n    }\n\n    /**\n     * Destroys the hls adapter.\n     * @function destroy\n     * @override\n     * @returns {Promise<*>} - The destroy promise.\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      var _this4 = this;\n\n      return _get(HlsAdapter.prototype.__proto__ || Object.getPrototypeOf(HlsAdapter.prototype), 'destroy', this).call(this).then(function () {\n        HlsAdapter._logger.debug('destroy');\n        _this4._loadPromise = null;\n        _this4._playerTracks = [];\n        _this4._removeBindings();\n        _this4._hls.detachMedia();\n        _this4._hls.destroy();\n      });\n    }\n\n    /**\n     * Parse the hls tracks into player tracks.\n     * @param {any} data - The event data.\n     * @returns {Array<Track>} - The parsed tracks.\n     * @private\n     */\n\n  }, {\n    key: '_parseTracks',\n    value: function _parseTracks(data) {\n      var audioTracks = this._parseAudioTracks(data.audioTracks || []);\n      var videoTracks = this._parseVideoTracks(data.levels || []);\n      var textTracks = this._parseTextTracks(this._hls.subtitleTracks || []);\n      return audioTracks.concat(videoTracks).concat(textTracks);\n    }\n\n    /**\n     * Parse hls audio tracks into player audio tracks.\n     * @param {Array<Object>} hlsAudioTracks - The hls audio tracks.\n     * @returns {Array<AudioTrack>} - The parsed audio tracks.\n     * @private\n     */\n\n  }, {\n    key: '_parseAudioTracks',\n    value: function _parseAudioTracks(hlsAudioTracks) {\n      var audioTracks = [];\n      for (var i = 0; i < hlsAudioTracks.length; i++) {\n        // Create audio tracks\n        var settings = {\n          id: hlsAudioTracks[i].id,\n          active: this._hls.audioTrack === hlsAudioTracks[i].id,\n          label: hlsAudioTracks[i].name,\n          language: hlsAudioTracks[i].lang,\n          index: i\n        };\n        audioTracks.push(new _playkitJs.AudioTrack(settings));\n      }\n      return audioTracks;\n    }\n\n    /**\n     * Parse hls video tracks into player video tracks.\n     * @param {Array<Object>} hlsVideoTracks - The hls video tracks.\n     * @returns {Array<VideoTrack>} - The parsed video tracks.\n     * @private\n     */\n\n  }, {\n    key: '_parseVideoTracks',\n    value: function _parseVideoTracks(hlsVideoTracks) {\n      var videoTracks = [];\n      for (var i = 0; i < hlsVideoTracks.length; i++) {\n        // Create video tracks\n        var settings = {\n          active: this._hls.startLevel === i,\n          label: hlsVideoTracks[i].name,\n          bandwidth: hlsVideoTracks[i].bitrate,\n          width: hlsVideoTracks[i].width,\n          height: hlsVideoTracks[i].height,\n          language: '',\n          index: i\n        };\n        videoTracks.push(new _playkitJs.VideoTrack(settings));\n      }\n      return videoTracks;\n    }\n\n    /**\n     * Parse hls text tracks into player text tracks.\n     * @param {Array<Object>} hlsTextTracks - The hls text tracks.\n     * @returns {Array<TextTrack>} - The parsed text tracks.\n     * @private\n     */\n\n  }, {\n    key: '_parseTextTracks',\n    value: function _parseTextTracks(hlsTextTracks) {\n      var textTracks = [];\n      for (var i = 0; i < hlsTextTracks.length; i++) {\n        // Create text tracks\n        var settings = {\n          id: hlsTextTracks[i].id,\n          active: hlsTextTracks[i].default,\n          label: hlsTextTracks[i].name,\n          kind: hlsTextTracks[i].type.toLowerCase(),\n          language: hlsTextTracks[i].lang,\n          index: i\n        };\n        textTracks.push(new _playkitJs.TextTrack(settings));\n      }\n      return textTracks;\n    }\n\n    /**\n     * Select an audio track.\n     * @function selectAudioTrack\n     * @param {AudioTrack} audioTrack - the audio track to select.\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'selectAudioTrack',\n    value: function selectAudioTrack(audioTrack) {\n      if (audioTrack instanceof _playkitJs.AudioTrack && !audioTrack.active && this._hls.audioTracks) {\n        this._hls.audioTrack = audioTrack.id;\n      }\n    }\n\n    /**\n     * Select a video track.\n     * @function selectVideoTrack\n     * @param {VideoTrack} videoTrack - the track to select.\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'selectVideoTrack',\n    value: function selectVideoTrack(videoTrack) {\n      if (videoTrack instanceof _playkitJs.VideoTrack && (!videoTrack.active || this.isAdaptiveBitrateEnabled()) && this._hls.levels) {\n        if (this.isAdaptiveBitrateEnabled()) {\n          this._trigger(_playkitJs.BaseMediaSourceAdapter.CustomEvents.ABR_MODE_CHANGED, { mode: 'manual' });\n        }\n        this._hls.currentLevel = videoTrack.index;\n      }\n    }\n\n    /**\n     * Select a text track.\n     * @function selectTextTrack\n     * @param {TextTrack} textTrack - the track to select.\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'selectTextTrack',\n    value: function selectTextTrack(textTrack) {\n      if (textTrack instanceof _playkitJs.TextTrack && !textTrack.active && this._videoElement.textTracks) {\n        this._disableAllTextTracks();\n        this._videoElement.textTracks[textTrack.index].mode = 'hidden';\n        HlsAdapter._logger.debug('Text track changed', textTrack);\n        this._onTrackChanged(textTrack);\n      }\n    }\n\n    /** Hide the text track\n     * @function hideTextTrack\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'hideTextTrack',\n    value: function hideTextTrack() {\n      this._disableAllTextTracks();\n    }\n\n    /**\n     * Enables adaptive bitrate switching according to hls.js logic.\n     * @function enableAdaptiveBitrate\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'enableAdaptiveBitrate',\n    value: function enableAdaptiveBitrate() {\n      if (!this.isAdaptiveBitrateEnabled()) {\n        this._trigger(_playkitJs.BaseMediaSourceAdapter.CustomEvents.ABR_MODE_CHANGED, { mode: 'auto' });\n        this._hls.nextLevel = -1;\n      }\n    }\n\n    /**\n     * Checking if adaptive bitrate switching is enabled.\n     * @function isAdaptiveBitrateEnabled\n     * @returns {boolean} - Whether adaptive bitrate is enabled.\n     * @public\n     */\n\n  }, {\n    key: 'isAdaptiveBitrateEnabled',\n    value: function isAdaptiveBitrateEnabled() {\n      return this._hls.autoLevelEnabled;\n    }\n\n    /**\n     * Returns the live edge\n     * @returns {number} - live edge\n     * @private\n     */\n\n  }, {\n    key: '_getLiveEdge',\n    value: function _getLiveEdge() {\n      try {\n        var liveEdge = void 0;\n        if (this._hls.config.liveSyncDuration) {\n          liveEdge = this._videoElement.duration - this._hls.config.liveSyncDuration;\n        } else {\n          liveEdge = this._videoElement.duration - this._hls.config.liveSyncDurationCount * this._hls.levels[0].details.targetduration;\n        }\n        return liveEdge > 0 ? liveEdge : 0;\n      } catch (e) {\n        return NaN;\n      }\n    }\n\n    /**\n     * Seeking to live edge, calculated according hls configuration - liveSyncDuration or liveSyncDurationCount.\n     * @function seekToLiveEdge\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'seekToLiveEdge',\n    value: function seekToLiveEdge() {\n      try {\n        this._videoElement.currentTime = this._getLiveEdge();\n      } catch (e) {\n        return;\n      }\n    }\n\n    /**\n     * Checking if the current playback is live.\n     * @function isLive\n     * @returns {boolean} - Whether playback is live.\n     * @public\n     */\n\n  }, {\n    key: 'isLive',\n    value: function isLive() {\n      try {\n        return this._hls.levels[0].details.live;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    /**\n     * Fired after manifest has been loaded.\n     * @function _onManifestLoaded\n     * @param {string} event - The event name.\n     * @param {any} data - The event data object.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_onManifestLoaded',\n    value: function _onManifestLoaded(event, data) {\n      HlsAdapter._logger.debug('The source has been loaded successfully');\n      this._hls.startLoad();\n      this._playerTracks = this._parseTracks(data);\n    }\n\n    /**\n     * Triggers on video track selection (auto or manually) the 'videotrackchanged' event forward.\n     * @function _onLevelSwitched\n     * @param {string} event - The event name.\n     * @param {any} data - The event data object.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_onLevelSwitched',\n    value: function _onLevelSwitched(event, data) {\n      var videoTrack = this._playerTracks.find(function (track) {\n        return track instanceof _playkitJs.VideoTrack && track.index === data.level;\n      });\n      HlsAdapter._logger.debug('Video track changed', videoTrack);\n      this._onTrackChanged(videoTrack);\n    }\n\n    /**\n     * Triggers on audio track selection (auto or manually) the 'audiotrackchanged' event forward.\n     * @function _onAudioTrackSwitched\n     * @param {string} event - The event name.\n     * @param {any} data - The event data object.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_onAudioTrackSwitched',\n    value: function _onAudioTrackSwitched(event, data) {\n      var audioTrack = this._playerTracks.find(function (track) {\n        return track instanceof _playkitJs.AudioTrack && track.id === data.id;\n      });\n      HlsAdapter._logger.debug('Audio track changed', audioTrack);\n      this._onTrackChanged(audioTrack);\n    }\n\n    /**\n     * Disables all the video tag text tracks.\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_disableAllTextTracks',\n    value: function _disableAllTextTracks() {\n      var vidTextTracks = this._videoElement.textTracks;\n      for (var i = 0; i < vidTextTracks.length; i++) {\n        vidTextTracks[i].mode = 'disabled';\n      }\n    }\n\n    /**\n     * Handles hls errors.\n     * @param {any} data - The event data object.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_onError',\n    value: function _onError(data) {\n      var errorType = data.type;\n      var errorDetails = data.details;\n      var errorFatal = data.fatal;\n      if (errorFatal) {\n        var error = void 0;\n        switch (errorType) {\n          case _hls2.default.ErrorTypes.NETWORK_ERROR:\n            error = new _playkitJs.Error(_playkitJs.Error.Severity.CRITICAL, _playkitJs.Error.Category.NETWORK, _playkitJs.Error.Code.HTTP_ERROR, errorDetails);\n            break;\n          case _hls2.default.ErrorTypes.MEDIA_ERROR:\n            if (this._handleMediaError()) {\n              error = new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.MEDIA, _playkitJs.Error.Code.HLS_FATAL_MEDIA_ERROR, errorDetails);\n            } else {\n              error = new _playkitJs.Error(_playkitJs.Error.Severity.CRITICAL, _playkitJs.Error.Category.MEDIA, _playkitJs.Error.Code.HLS_FATAL_MEDIA_ERROR, errorDetails);\n            }\n            break;\n          default:\n            error = new _playkitJs.Error(_playkitJs.Error.Severity.CRITICAL, _playkitJs.Error.Category.PLAYER, _playkitJs.Error.Code.HLS_FATAL_MEDIA_ERROR, errorDetails);\n            break;\n        }\n        this._trigger(_playkitJs.BaseMediaSourceAdapter.Html5Events.ERROR, error);\n        if (error && error.severity === _playkitJs.Error.Severity.CRITICAL) {\n          this.destroy();\n        }\n      } else {\n        var _ref = _errors.HlsJsErrorMap[errorDetails] || { category: 0, code: 0 },\n            category = _ref.category,\n            code = _ref.code;\n\n        HlsAdapter._logger.warn(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, category, code, errorDetails));\n      }\n    }\n\n    /**\n     * Tries to handle media errors via hls.js error handlers\n     * @returns {boolean} - if media error is handled or not\n     * @private\n     */\n\n  }, {\n    key: '_handleMediaError',\n    value: function _handleMediaError() {\n      var now = performance.now();\n      var recover = true;\n      if (this._checkTimeDeltaHasPassed(now, this._recoverDecodingErrorDate, this._config.recoverDecodingErrorDelay)) {\n        this._recoverDecodingError();\n      } else {\n        if (this._checkTimeDeltaHasPassed(now, this._recoverSwapAudioCodecDate, this._config.recoverSwapAudioCodecDelay)) {\n          this._recoverSwapAudioCodec();\n        } else {\n          recover = false;\n          HlsAdapter._logger.error(\"cannot recover, last media error recovery failed\");\n        }\n      }\n      return recover;\n    }\n\n    /**\n     * Check if time ahs passed a certain delta\n     * @param {number} now - current time\n     * @param {number} then - previous time\n     * @param {number} delay - time delta in ms\n     * @returns {boolean} - if time delta has\n     * @private\n     */\n\n  }, {\n    key: '_checkTimeDeltaHasPassed',\n    value: function _checkTimeDeltaHasPassed(now, then, delay) {\n      return !then || now - then > delay;\n    }\n\n    /**\n     * handle recover from decoding error\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_recoverDecodingError',\n    value: function _recoverDecodingError() {\n      this._recoverDecodingErrorDate = performance.now();\n      HlsAdapter._logger.warn(\"try to recover media Error\");\n      this.hls.recoverMediaError();\n    }\n\n    /**\n     * handle recover from decoding error by swaping audio codec\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_recoverSwapAudioCodec',\n    value: function _recoverSwapAudioCodec() {\n      this._recoverSwapAudioCodecDate = performance.now();\n      HlsAdapter._logger.warn(\"try to swap Audio Codec and recover media Error\");\n      this.hls.swapAudioCodec();\n      this.hls.recoverMediaError();\n    }\n\n    /**\n     * Removes hls.js bindings.\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_removeBindings',\n    value: function _removeBindings() {\n      this._hls.off(_hls2.default.Events.ERROR, this._onError);\n      this._hls.off(_hls2.default.Events.LEVEL_SWITCHED, this._onLevelSwitched);\n      this._hls.off(_hls2.default.Events.AUDIO_TRACK_SWITCHED, this._onAudioTrackSwitched);\n    }\n\n    /**\n     * Getter for the src that the adapter plays on the video element.\n     * In case the adapter preformed a load it will return the manifest url.\n     * @public\n     * @returns {string} - The src url.\n     */\n\n  }, {\n    key: 'src',\n    get: function get() {\n      if (this._loadPromise && this._sourceObj) {\n        return this._sourceObj.url;\n      }\n      return \"\";\n    }\n\n    /**\n     * Get the duration in seconds.\n     * @returns {Number} - The playback duration.\n     * @public\n     */\n\n  }, {\n    key: 'duration',\n    get: function get() {\n      if (this.isLive()) {\n        return this._getLiveEdge();\n      } else {\n        return _get(HlsAdapter.prototype.__proto__ || Object.getPrototypeOf(HlsAdapter.prototype), 'duration', this);\n      }\n    }\n  }]);\n\n  return HlsAdapter;\n}(_playkitJs.BaseMediaSourceAdapter);\n\nHlsAdapter.id = 'HlsAdapter';\nHlsAdapter._logger = _playkitJs.BaseMediaSourceAdapter.getLogger(HlsAdapter.id);\nHlsAdapter._hlsMimeTypes = ['application/x-mpegurl', 'application/vnd.apple.mpegurl', 'audio/mpegurl', 'audio/x-mpegurl', 'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];\nexports.default = HlsAdapter;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n\t\"recoverDecodingErrorDelay\": 3000,\n\t\"recoverSwapAudioCodecDelay\": 3000,\n\t\"fragLoadingMaxRetry\": 4\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HlsJsErrorMap = undefined;\n\nvar _HlsJsErrorMap;\n\nvar _hls = __webpack_require__(1);\n\nvar _hls2 = _interopRequireDefault(_hls);\n\nvar _playkitJs = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar HlsJsErrorMap = (_HlsJsErrorMap = {}, _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.MANIFEST_LOAD_ERROR, {\n  category: _playkitJs.Error.Category.MANIFEST,\n  code: _playkitJs.Error.Code.HTTP_ERROR\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.MANIFEST_LOAD_TIMEOUT, {\n  category: _playkitJs.Error.Category.MANIFEST,\n  code: _playkitJs.Error.Code.TIMEOUT\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.MANIFEST_PARSING_ERROR, {\n  category: _playkitJs.Error.Category.MANIFEST,\n  code: _playkitJs.Error.Code.HLSJS_CANNOT_PARSE\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.LEVEL_LOAD_ERROR, {\n  category: _playkitJs.Error.Category.NETWORK,\n  code: _playkitJs.Error.Code.HTTP_ERROR\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.LEVEL_LOAD_TIMEOUT, {\n  category: _playkitJs.Error.Category.NETWORK,\n  code: _playkitJs.Error.Code.TIMEOUT\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.LEVEL_SWITCH_ERROR, {\n  category: _playkitJs.Error.Category.PLAYER,\n  code: _playkitJs.Error.Code.BITRATE_SWITCH_ISSUE\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.FRAG_LOAD_ERROR, {\n  category: _playkitJs.Error.Category.NETWORK,\n  code: _playkitJs.Error.Code.HTTP_ERROR\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.FRAG_LOOP_LOADING_ERROR, {\n  category: _playkitJs.Error.Category.NETWORK,\n  code: _playkitJs.Error.Code.HTTP_ERROR\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.FRAG_LOAD_TIMEOUT, {\n  category: _playkitJs.Error.Category.NETWORK,\n  code: _playkitJs.Error.Code.TIMEOUT\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.FRAG_PARSING_ERROR, {\n  category: _playkitJs.Error.Category.MEDIA,\n  code: _playkitJs.Error.Code.HLS_FRAG_PARSING_ERROR\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.BUFFER_APPEND_ERROR, {\n  category: _playkitJs.Error.Category.MEDIA,\n  code: _playkitJs.Error.Code.HLS_BUFFER_APPEND_ISSUE\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.BUFFER_APPENDING_ERROR, {\n  category: _playkitJs.Error.Category.MEDIA,\n  code: _playkitJs.Error.Code.HLS_BUFFER_APPENDING_ISSUE\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.BUFFER_STALLED_ERROR, {\n  category: _playkitJs.Error.Category.MEDIA,\n  code: _playkitJs.Error.Code.HLS_BUFFER_STALLED_ERROR\n}), _HlsJsErrorMap);\n\nexports.HlsJsErrorMap = HlsJsErrorMap;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// playkit-hls.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2a6bb622a298a5cddf82","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"playkit-js\",\"commonjs2\":\"playkit-js\",\"amd\":\"playkit-js\",\"root\":\"Playkit\"}\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"hls.js\",\"commonjs2\":\"hls.js\",\"amd\":\"hls.js\",\"root\":\"Hls\"}\n// module id = 1\n// module chunks = 0","// @flow\nimport {registerMediaSourceAdapter} from 'playkit-js'\nimport HlsAdapter from'./hls-adapter'\n\ndeclare var __VERSION__: string;\ndeclare var __NAME__: string;\n\nexport default HlsAdapter;\nexport {__VERSION__ as VERSION, __NAME__ as NAME};\n\n// Register hls adapter to the media source adapter provider.\nif (HlsAdapter.isSupported()) {\n  registerMediaSourceAdapter(HlsAdapter);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","//@flow\nimport Hlsjs from 'hls.js'\nimport {DefaultConfig} from './default-config'\nimport {HlsJsErrorMap, type ErrorDetailsType} from \"./errors\"\nimport {BaseMediaSourceAdapter, Utils, Error} from 'playkit-js'\nimport {Track, VideoTrack, AudioTrack, TextTrack} from 'playkit-js'\n\n/**\n * Adapter of hls.js lib for hls content.\n * @classdesc\n */\nexport default class HlsAdapter extends BaseMediaSourceAdapter {\n  /**\n   * The id of the adapter.\n   * @member {string} id\n   * @static\n   * @private\n   */\n  static id: string = 'HlsAdapter';\n  /**\n   * The adapter logger.\n   * @member {any} _logger\n   * @static\n   * @private\n   */\n  static _logger = BaseMediaSourceAdapter.getLogger(HlsAdapter.id);\n  /**\n   * The supported mime types by the hls adapter.\n   * @member {Array<string>} _hlsMimeType\n   * @static\n   * @private\n   */\n  static _hlsMimeTypes: Array<string> = [\n    'application/x-mpegurl',\n    'application/vnd.apple.mpegurl',\n    'audio/mpegurl',\n    'audio/x-mpegurl',\n    'video/x-mpegurl',\n    'video/mpegurl',\n    'application/mpegurl'\n  ];\n  /**\n   * The hls player instance.\n   * @member {any} _hls\n   * @private\n   */\n  _hls: any;\n\n  /**\n   * last recover date from decoding error\n   * @type {number}\n   * @private\n   */\n  _recoverDecodingErrorDate: number;\n\n  /**\n   * last recover date from audio swap codec operation\n   * @type {number}\n   * @private\n   */\n  _recoverSwapAudioCodecDate: number;\n\n  /**\n   * The load promise\n   * @member {Promise<Object>} - _loadPromise\n   * @type {Promise<Object>}\n   * @private\n   */\n  _loadPromise: ?Promise<Object>;\n  /**\n   * Reference to the player tracks.\n   * @member {Array<Track>} - _playerTracks\n   * @type {Array<Track>}\n   * @private\n   */\n  _playerTracks: Array<Track>;\n\n  /**\n   * Factory method to create media source adapter.\n   * @function createAdapter\n   * @param {HTMLVideoElement} videoElement - The video element that the media source adapter work with.\n   * @param {Object} source - The source Object.\n   * @param {Object} config - The player configuration.\n   * @returns {IMediaSourceAdapter} - New instance of the run time media source adapter.\n   * @static\n   */\n  static createAdapter(videoElement: HTMLVideoElement, source: Source, config: Object): IMediaSourceAdapter {\n    let hlsConfig = {};\n    if (Utils.Object.hasPropertyPath(config, 'playback.options.html5.hls')) {\n      hlsConfig = config.playback.options.html5.hls;\n    }\n    return new this(videoElement, source, hlsConfig);\n  }\n\n  /**\n   * Checks if hls adapter can play a given mime type.\n   * @function canPlayType\n   * @param {string} mimeType - The mime type to check.\n   * @returns {boolean} - Whether the hls adapter can play a specific mime type.\n   * @static\n   */\n  static canPlayType(mimeType: string): boolean {\n    let canHlsPlayType = (typeof mimeType === 'string') ? HlsAdapter._hlsMimeTypes.includes(mimeType.toLowerCase()) : false;\n    HlsAdapter._logger.debug('canPlayType result for mimeType:' + mimeType + ' is ' + canHlsPlayType.toString());\n    return canHlsPlayType;\n  }\n\n  /**\n   * Checks if hls adapter can play a given drm data.\n   * For hls.js it always returns false.\n   * @returns {boolean} - Whether the hls adapter can play a specific drm data.\n   * @static\n   */\n  static canPlayDrm(): boolean {\n    HlsAdapter._logger.warn('canPlayDrm result is false');\n    return false;\n  }\n\n  /**\n   * Checks if the hls adapter is supported.\n   * @function isSupported\n   * @returns {boolean} - Whether hls is supported.\n   * @static\n   */\n  static isSupported(): boolean {\n    let isHlsSupported = Hlsjs.isSupported();\n    HlsAdapter._logger.debug('isSupported:' + isHlsSupported);\n    return isHlsSupported;\n  }\n\n  /**\n   * @constructor\n   * @param {HTMLVideoElement} videoElement - The video element which will bind to the hls adapter\n   * @param {Object} source - The source object\n   * @param {Object} config - The media source adapter configuration\n   */\n  constructor(videoElement: HTMLVideoElement, source: Source, config: Object) {\n    HlsAdapter._logger.debug('Creating adapter. Hls version: ' + Hlsjs.version);\n    super(videoElement, source, config);\n    this._config = Utils.Object.mergeDeep({}, this._config, DefaultConfig);\n    this._hls = new Hlsjs(this._config);\n    this._addBindings();\n  }\n\n  /**\n   * Adds the required bindings with hls.js.\n   * @function _addBindings\n   * @private\n   * @returns {void}\n   */\n  _addBindings(): void {\n    this._hls.on(Hlsjs.Events.ERROR, (e, data) => {\n      this._onError(data);\n    });\n    this._hls.on(Hlsjs.Events.MANIFEST_LOADED, this._onManifestLoaded.bind(this));\n    this._hls.on(Hlsjs.Events.LEVEL_SWITCHED, this._onLevelSwitched.bind(this));\n    this._hls.on(Hlsjs.Events.AUDIO_TRACK_SWITCHED, this._onAudioTrackSwitched.bind(this));\n  }\n\n  /**\n   * Load the video source\n   * @function load\n   * @param {number} startTime - Optional time to start the video from.\n   * @returns {Promise<Object>} - The loaded data\n   * @override\n   */\n  load(startTime: ?number): Promise<Object> {\n    if (!this._loadPromise) {\n      this._loadPromise = new Promise((resolve) => {\n        let onLevelUpdated = () => {\n          this._hls.off(Hlsjs.Events.LEVEL_UPDATED, onLevelUpdated);\n          resolve({tracks: this._playerTracks});\n        };\n        this._hls.on(Hlsjs.Events.LEVEL_UPDATED, onLevelUpdated);\n        if (startTime) {\n          this._hls.startPosition = startTime;\n        }\n        if (this._sourceObj && this._sourceObj.url) {\n          this._hls.loadSource(this._sourceObj.url);\n          this._hls.attachMedia(this._videoElement);\n          this._trigger(BaseMediaSourceAdapter.CustomEvents.ABR_MODE_CHANGED, {mode: this.isAdaptiveBitrateEnabled() ? 'auto' : 'manual'});\n        }\n      });\n    }\n    return this._loadPromise;\n  }\n\n  /**\n   * Destroys the hls adapter.\n   * @function destroy\n   * @override\n   * @returns {Promise<*>} - The destroy promise.\n   */\n  destroy(): Promise<*> {\n    return super.destroy().then(() => {\n      HlsAdapter._logger.debug('destroy');\n      this._loadPromise = null;\n      this._playerTracks = [];\n      this._removeBindings();\n      this._hls.detachMedia();\n      this._hls.destroy();\n    });\n  }\n\n  /**\n   * Parse the hls tracks into player tracks.\n   * @param {any} data - The event data.\n   * @returns {Array<Track>} - The parsed tracks.\n   * @private\n   */\n  _parseTracks(data: any): Array<Track> {\n    let audioTracks = this._parseAudioTracks(data.audioTracks || []);\n    let videoTracks = this._parseVideoTracks(data.levels || []);\n    let textTracks = this._parseTextTracks(this._hls.subtitleTracks || []);\n    return audioTracks.concat(videoTracks).concat(textTracks);\n  }\n\n  /**\n   * Parse hls audio tracks into player audio tracks.\n   * @param {Array<Object>} hlsAudioTracks - The hls audio tracks.\n   * @returns {Array<AudioTrack>} - The parsed audio tracks.\n   * @private\n   */\n  _parseAudioTracks(hlsAudioTracks: Array<Object>): Array<AudioTrack> {\n    let audioTracks = [];\n    for (let i = 0; i < hlsAudioTracks.length; i++) {\n      // Create audio tracks\n      let settings = {\n        id: hlsAudioTracks[i].id,\n        active: this._hls.audioTrack === hlsAudioTracks[i].id,\n        label: hlsAudioTracks[i].name,\n        language: hlsAudioTracks[i].lang,\n        index: i\n      };\n      audioTracks.push(new AudioTrack(settings));\n    }\n    return audioTracks;\n  }\n\n  /**\n   * Parse hls video tracks into player video tracks.\n   * @param {Array<Object>} hlsVideoTracks - The hls video tracks.\n   * @returns {Array<VideoTrack>} - The parsed video tracks.\n   * @private\n   */\n  _parseVideoTracks(hlsVideoTracks: Array<Object>): Array<VideoTrack> {\n    let videoTracks = [];\n    for (let i = 0; i < hlsVideoTracks.length; i++) {\n      // Create video tracks\n      let settings = {\n        active: this._hls.startLevel === i,\n        label: hlsVideoTracks[i].name,\n        bandwidth: hlsVideoTracks[i].bitrate,\n        width: hlsVideoTracks[i].width,\n        height: hlsVideoTracks[i].height,\n        language: '',\n        index: i\n      };\n      videoTracks.push(new VideoTrack(settings));\n    }\n    return videoTracks;\n  }\n\n  /**\n   * Parse hls text tracks into player text tracks.\n   * @param {Array<Object>} hlsTextTracks - The hls text tracks.\n   * @returns {Array<TextTrack>} - The parsed text tracks.\n   * @private\n   */\n  _parseTextTracks(hlsTextTracks: Array<Object>): Array<TextTrack> {\n    let textTracks = [];\n    for (let i = 0; i < hlsTextTracks.length; i++) {\n      // Create text tracks\n      let settings = {\n        id: hlsTextTracks[i].id,\n        active: hlsTextTracks[i].default,\n        label: hlsTextTracks[i].name,\n        kind: hlsTextTracks[i].type.toLowerCase(),\n        language: hlsTextTracks[i].lang,\n        index: i\n      };\n      textTracks.push(new TextTrack(settings));\n    }\n    return textTracks;\n  }\n\n  /**\n   * Select an audio track.\n   * @function selectAudioTrack\n   * @param {AudioTrack} audioTrack - the audio track to select.\n   * @returns {void}\n   * @public\n   */\n  selectAudioTrack(audioTrack: AudioTrack): void {\n    if (audioTrack instanceof AudioTrack && !audioTrack.active && this._hls.audioTracks) {\n      this._hls.audioTrack = audioTrack.id;\n    }\n  }\n\n  /**\n   * Select a video track.\n   * @function selectVideoTrack\n   * @param {VideoTrack} videoTrack - the track to select.\n   * @returns {void}\n   * @public\n   */\n  selectVideoTrack(videoTrack: VideoTrack): void {\n    if (videoTrack instanceof VideoTrack && (!videoTrack.active || this.isAdaptiveBitrateEnabled()) && this._hls.levels) {\n      if (this.isAdaptiveBitrateEnabled()) {\n        this._trigger(BaseMediaSourceAdapter.CustomEvents.ABR_MODE_CHANGED, {mode: 'manual'});\n      }\n      this._hls.currentLevel = videoTrack.index;\n    }\n  }\n\n  /**\n   * Select a text track.\n   * @function selectTextTrack\n   * @param {TextTrack} textTrack - the track to select.\n   * @returns {void}\n   * @public\n   */\n  selectTextTrack(textTrack: TextTrack): void {\n    if (textTrack instanceof TextTrack && !textTrack.active && this._videoElement.textTracks) {\n      this._disableAllTextTracks();\n      this._videoElement.textTracks[textTrack.index].mode = 'hidden';\n      HlsAdapter._logger.debug('Text track changed', textTrack);\n      this._onTrackChanged(textTrack);\n    }\n  }\n\n  /** Hide the text track\n   * @function hideTextTrack\n   * @returns {void}\n   * @public\n   */\n  hideTextTrack(): void {\n    this._disableAllTextTracks();\n  }\n\n  /**\n   * Enables adaptive bitrate switching according to hls.js logic.\n   * @function enableAdaptiveBitrate\n   * @returns {void}\n   * @public\n   */\n  enableAdaptiveBitrate(): void {\n    if (!this.isAdaptiveBitrateEnabled()) {\n      this._trigger(BaseMediaSourceAdapter.CustomEvents.ABR_MODE_CHANGED, {mode: 'auto'});\n      this._hls.nextLevel = -1;\n    }\n  }\n\n  /**\n   * Checking if adaptive bitrate switching is enabled.\n   * @function isAdaptiveBitrateEnabled\n   * @returns {boolean} - Whether adaptive bitrate is enabled.\n   * @public\n   */\n  isAdaptiveBitrateEnabled(): boolean {\n    return this._hls.autoLevelEnabled;\n  }\n\n  /**\n   * Returns the live edge\n   * @returns {number} - live edge\n   * @private\n   */\n  _getLiveEdge(): number {\n    try {\n      let liveEdge;\n      if (this._hls.config.liveSyncDuration) {\n        liveEdge = this._videoElement.duration - this._hls.config.liveSyncDuration;\n      } else {\n        liveEdge = this._videoElement.duration - this._hls.config.liveSyncDurationCount * this._hls.levels[0].details.targetduration;\n      }\n      return liveEdge > 0 ? liveEdge : 0;\n    } catch (e) {\n      return NaN;\n    }\n  }\n\n  /**\n   * Seeking to live edge, calculated according hls configuration - liveSyncDuration or liveSyncDurationCount.\n   * @function seekToLiveEdge\n   * @returns {void}\n   * @public\n   */\n  seekToLiveEdge(): void {\n    try {\n      this._videoElement.currentTime = this._getLiveEdge();\n    } catch (e) {\n      return;\n    }\n  }\n\n  /**\n   * Checking if the current playback is live.\n   * @function isLive\n   * @returns {boolean} - Whether playback is live.\n   * @public\n   */\n  isLive(): boolean {\n    try {\n      return this._hls.levels[0].details.live;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Fired after manifest has been loaded.\n   * @function _onManifestLoaded\n   * @param {string} event - The event name.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onManifestLoaded(event: string, data: any): void {\n    HlsAdapter._logger.debug('The source has been loaded successfully');\n    this._hls.startLoad();\n    this._playerTracks = this._parseTracks(data);\n  }\n\n  /**\n   * Triggers on video track selection (auto or manually) the 'videotrackchanged' event forward.\n   * @function _onLevelSwitched\n   * @param {string} event - The event name.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onLevelSwitched(event: string, data: any): void {\n    let videoTrack = this._playerTracks.find((track) => {\n      return (track instanceof VideoTrack && track.index === data.level);\n    });\n    HlsAdapter._logger.debug('Video track changed', videoTrack);\n    this._onTrackChanged(videoTrack);\n  }\n\n  /**\n   * Triggers on audio track selection (auto or manually) the 'audiotrackchanged' event forward.\n   * @function _onAudioTrackSwitched\n   * @param {string} event - The event name.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onAudioTrackSwitched(event: string, data: any): void {\n    let audioTrack = this._playerTracks.find((track) => {\n      return (track instanceof AudioTrack && track.id === data.id);\n    });\n    HlsAdapter._logger.debug('Audio track changed', audioTrack);\n    this._onTrackChanged(audioTrack);\n  }\n\n  /**\n   * Disables all the video tag text tracks.\n   * @returns {void}\n   * @private\n   */\n  _disableAllTextTracks() {\n    let vidTextTracks = this._videoElement.textTracks;\n    for (let i = 0; i < vidTextTracks.length; i++) {\n      vidTextTracks[i].mode = 'disabled';\n    }\n  }\n\n  /**\n   * Handles hls errors.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onError(data: any): void {\n    const errorType = data.type;\n    const errorDetails = data.details;\n    const errorFatal = data.fatal;\n    if (errorFatal) {\n      let error: typeof Error;\n      switch (errorType) {\n        case Hlsjs.ErrorTypes.NETWORK_ERROR:\n          error = new Error(\n            Error.Severity.CRITICAL,\n            Error.Category.NETWORK,\n            Error.Code.HTTP_ERROR,\n            errorDetails);\n          break;\n        case Hlsjs.ErrorTypes.MEDIA_ERROR:\n          if (this._handleMediaError()) {\n            error = new Error(\n              Error.Severity.RECOVERABLE,\n              Error.Category.MEDIA,\n              Error.Code.HLS_FATAL_MEDIA_ERROR,\n              errorDetails);\n          } else {\n            error = new Error(\n              Error.Severity.CRITICAL,\n              Error.Category.MEDIA,\n              Error.Code.HLS_FATAL_MEDIA_ERROR,\n              errorDetails);\n          }\n          break;\n        default:\n          error = new Error(\n            Error.Severity.CRITICAL,\n            Error.Category.PLAYER,\n            Error.Code.HLS_FATAL_MEDIA_ERROR,\n            errorDetails);\n          break;\n      }\n      this._trigger(BaseMediaSourceAdapter.Html5Events.ERROR, error);\n      if (error && error.severity === Error.Severity.CRITICAL) {\n        this.destroy();\n      }\n    } else {\n      const {category, code}: ErrorDetailsType = HlsJsErrorMap[errorDetails] || {category: 0, code: 0};\n      HlsAdapter._logger.warn(new Error(\n        Error.Severity.RECOVERABLE,\n        category,\n        code,\n        errorDetails));\n    }\n  }\n\n  /**\n   * Tries to handle media errors via hls.js error handlers\n   * @returns {boolean} - if media error is handled or not\n   * @private\n   */\n  _handleMediaError(): boolean {\n    const now: number = performance.now();\n    let recover = true;\n    if (this._checkTimeDeltaHasPassed(now, this._recoverDecodingErrorDate, this._config.recoverDecodingErrorDelay)) {\n      this._recoverDecodingError();\n    } else {\n      if (this._checkTimeDeltaHasPassed(now, this._recoverSwapAudioCodecDate, this._config.recoverSwapAudioCodecDelay)) {\n        this._recoverSwapAudioCodec();\n      } else {\n        recover = false;\n        HlsAdapter._logger.error(\"cannot recover, last media error recovery failed\");\n      }\n    }\n    return recover;\n  }\n\n  /**\n   * Check if time ahs passed a certain delta\n   * @param {number} now - current time\n   * @param {number} then - previous time\n   * @param {number} delay - time delta in ms\n   * @returns {boolean} - if time delta has\n   * @private\n   */\n  _checkTimeDeltaHasPassed(now: number, then: number, delay: number): boolean {\n    return (!then || (now - then) > delay);\n  }\n\n  /**\n   * handle recover from decoding error\n   * @returns {void}\n   * @private\n   */\n  _recoverDecodingError(): void {\n    this._recoverDecodingErrorDate = performance.now();\n    HlsAdapter._logger.warn(\"try to recover media Error\");\n    this.hls.recoverMediaError();\n  }\n\n  /**\n   * handle recover from decoding error by swaping audio codec\n   * @returns {void}\n   * @private\n   */\n  _recoverSwapAudioCodec(): void {\n    this._recoverSwapAudioCodecDate = performance.now();\n    HlsAdapter._logger.warn(\"try to swap Audio Codec and recover media Error\");\n    this.hls.swapAudioCodec();\n    this.hls.recoverMediaError();\n  }\n\n  /**\n   * Removes hls.js bindings.\n   * @returns {void}\n   * @private\n   */\n  _removeBindings(): void {\n    this._hls.off(Hlsjs.Events.ERROR, this._onError);\n    this._hls.off(Hlsjs.Events.LEVEL_SWITCHED, this._onLevelSwitched);\n    this._hls.off(Hlsjs.Events.AUDIO_TRACK_SWITCHED, this._onAudioTrackSwitched);\n  }\n\n  /**\n   * Getter for the src that the adapter plays on the video element.\n   * In case the adapter preformed a load it will return the manifest url.\n   * @public\n   * @returns {string} - The src url.\n   */\n  get src(): string {\n    if (this._loadPromise && this._sourceObj) {\n      return this._sourceObj.url;\n    }\n    return \"\";\n  }\n\n  /**\n   * Get the duration in seconds.\n   * @returns {Number} - The playback duration.\n   * @public\n   */\n  get duration(): number {\n    if (this.isLive()) {\n      return this._getLiveEdge();\n    } else {\n      return super.duration;\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./hls-adapter.js","module.exports = {\n\t\"recoverDecodingErrorDelay\": 3000,\n\t\"recoverSwapAudioCodecDelay\": 3000,\n\t\"fragLoadingMaxRetry\": 4\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./default-config.json\n// module id = 4\n// module chunks = 0","// @flow\nimport Hlsjs from 'hls.js'\nimport {Error} from 'playkit-js'\n\ntype ErrorDetailsType = {category: number, code: number};\ntype HlsJsErrorMapType = {[name: string]: ErrorDetailsType};\n\nconst HlsJsErrorMap: HlsJsErrorMapType = {\n  [Hlsjs.ErrorDetails.MANIFEST_LOAD_ERROR]: {\n    category: Error.Category.MANIFEST,\n    code: Error.Code.HTTP_ERROR\n  },\n  [Hlsjs.ErrorDetails.MANIFEST_LOAD_TIMEOUT]: {\n    category: Error.Category.MANIFEST,\n    code: Error.Code.TIMEOUT\n  },\n  [Hlsjs.ErrorDetails.MANIFEST_PARSING_ERROR]: {\n    category: Error.Category.MANIFEST,\n    code: Error.Code.HLSJS_CANNOT_PARSE\n  },\n  [Hlsjs.ErrorDetails.LEVEL_LOAD_ERROR]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.HTTP_ERROR\n  },\n  [Hlsjs.ErrorDetails.LEVEL_LOAD_TIMEOUT]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.TIMEOUT\n  },\n  [Hlsjs.ErrorDetails.LEVEL_SWITCH_ERROR]: {\n    category: Error.Category.PLAYER,\n    code: Error.Code.BITRATE_SWITCH_ISSUE\n  },\n  [Hlsjs.ErrorDetails.FRAG_LOAD_ERROR]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.HTTP_ERROR\n  },\n  [Hlsjs.ErrorDetails.FRAG_LOOP_LOADING_ERROR]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.HTTP_ERROR\n  },\n  [Hlsjs.ErrorDetails.FRAG_LOAD_TIMEOUT]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.TIMEOUT\n  },\n  [Hlsjs.ErrorDetails.FRAG_PARSING_ERROR]: {\n    category: Error.Category.MEDIA,\n    code: Error.Code.HLS_FRAG_PARSING_ERROR\n  },\n  [Hlsjs.ErrorDetails.BUFFER_APPEND_ERROR]: {\n    category: Error.Category.MEDIA,\n    code: Error.Code.HLS_BUFFER_APPEND_ISSUE\n  },\n  [Hlsjs.ErrorDetails.BUFFER_APPENDING_ERROR]: {\n    category: Error.Category.MEDIA,\n    code: Error.Code.HLS_BUFFER_APPENDING_ISSUE\n  },\n  [Hlsjs.ErrorDetails.BUFFER_STALLED_ERROR]: {\n    category: Error.Category.MEDIA,\n    code: Error.Code.HLS_BUFFER_STALLED_ERROR\n  }\n};\n\nexport {HlsJsErrorMap};\nexport type {ErrorDetailsType};\n\n\n\n// WEBPACK FOOTER //\n// ./errors.js"],"sourceRoot":""}